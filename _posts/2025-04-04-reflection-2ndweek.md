---
title: "[커널아카데미] 백엔드 부트캠프 2주차 - OOP 재밌네"
excerpt: "2주차 회고"

categories:
  - Reflection
tags:
  - ["커널아카데미", "패스트캠퍼스"]

permalink: /reflection/2ndweek/

toc: true
toc_sticky: true

date: 2025-04-04
last_modified_at: 2025-04-04
---

# 📜2주차 회고

# 2주차 회고

이번 주에는 객체지향 개념에 대해 학습했다. 강의는 기본적인 개념을 다루지 않고, 학생들이 어느 정도 내용을 알고 있다는 가정 하에 진행되었다. 기본 개념은 유튜브 강의를 통해 예습할 수 있기 때문에 미리 학습하고 강의를 들으면 심화적인 내용을 깊이 이해하는 데 도움이 된다.

---

## 1. 모든 것은 변경에 유리하기 위하여

객체지향의 핵심 목표는 변경에 유리한 코드를 작성하는 것이다. 추상화, 다형성, 오버로딩, 오버라이딩 등 객체지향의 모든 개념은 코드의 변경을 용이하게 하기 위한 것이다. 자바의 버전이 업그레이드되면서 도입된 기능들도 변경에 유리하도록 설계된 것이 많다. 예를 들어, 인터페이스에 `default` 메서드를 추가할 수 있도록 한 것은 기존 인터페이스를 수정할 때 상속받은 클래스들까지 수정해야 하는 문제를 방지하기 위해서다.



---

## 2. JVM에서 `new` 연산자와 생성자의 실행 과정

자바에서 `new` 연산자를 사용하여 객체를 생성하면 JVM 내부적으로 여러 단계를 거쳐 객체가 생성되고 초기화된다. 이를 어셈블리 수준까지 살펴보면 다음과 같은 과정으로 진행된다.

### 1) `new` 연산자의 역할

`new` 연산자는 기본적으로 **힙(Heap)에 객체를 생성하고 해당 객체의 참조를 반환하는 역할**을 한다.

- 클래스 로드 (Class Loading): 클래스가 아직 로드되지 않았다면, 클래스 로더가 `.class` 파일을 찾아 JVM에 로드한다.
- 메모리 할당 (Memory Allocation): JVM의 힙 메모리에 새로운 객체를 위한 공간을 확보한다.
- 기본값 초기화 (Zero Initialization): 객체의 필드가 기본값(0, `null`, `false`)으로 초기화된다.
- 생성자 호출 (Constructor Call): 생성자가 실행되어 객체를 원하는 상태로 초기화한다.

### 2) 생성자의 실행 과정

생성자는 다음과 같은 순서로 실행된다.

1. 부모 클래스의 생성자 호출 (`super()`)
2. 필드 초기화 (명시적으로 초기화된 값 할당)
3. 인스턴스 초기화 블록 실행 (있을 경우)
4. 생성자 본문 실행

객체가 생성될 때 부모 클래스의 생성자가 먼저 실행되므로, 상속받은 필드들이 먼저 초기화된다. 이후 필드 초기화 → 인스턴스 초기화 블록 실행 → 생성자 본문 실행 순으로 진행된다.

### 3) 어셈블리 수준에서의 실행 흐름

다음과 같은 자바 코드가 있다고 하자.

```
public class Test {
    int x;

    public Test() {
        this.x = 42;
    }

    public static void main(String[] args) {
        Test obj = new Test();
    }
}
```

이를 바이트코드 수준에서 보면 다음과 같은 실행 흐름을 가진다.

```
0: new           #2      // Test 객체 생성
3: dup
4: invokespecial #3      // Test 생성자 호출
7: astore_1
```

이 바이트코드는 JIT 컴파일러에 의해 최적화된 기계어로 변환된다.

```
mov rdi, [Test.class]   ; Test 클래스의 메타데이터 로드
call malloc             ; 힙 메모리에 객체 생성
mov [rax], Test_vtable  ; 가상 테이블(vtable) 설정
call Test.constructor   ; 생성자 호출
```

객체 생성 과정에서 JVM은 `malloc`을 호출하여 힙에 메모리를 할당하고, 생성자를 호출하여 객체를 초기화하는 구조로 실행된다.

---

## 3. `this`는 언제 생성될까?

`this`는 생성자가 실행되기 전에 이미 존재하며, 생성자의 첫 번째 인자로 전달된다. 즉, `new` 연산자가 객체를 생성하는 순간부터 `this`는 유효한 상태다.

### `this`의 생성 시점

1. `new` 연산자 실행: 힙 메모리에 객체를 위한 공간을 할당하고 메모리 주소를 반환한다.
2. 기본값 초기화: 객체의 필드들이 기본값으로 설정된다.
3. 생성자 호출: 생성자의 첫 번째 인자로 `this`가 전달된다.
4. 생성자 내부에서 `this` 사용 가능: 필드 초기화 및 추가 로직 실행 가능

바이트코드를 살펴보면 `aload_0` 명령어가 `this`를 스택에 로드하는 과정이 보인다. 이는 생성자가 실행되기 전에 `this`가 이미 존재함을 의미한다.

---

## 4. 회고 및 정리

객체 지향 개념은 한 번만 공부하는 것이 아닌, 지속적으로 복습할 필요성을 느꼈다. 또한 JVM에서 어떻게 동작하는지 궁금해하며 공부하는 것이 설계 지향적인 개발자가 되기 위한 필수적인 요소가 될 것 같다. 
앞으로의 목표는 직접 설계를 할 때 좋은 아키텍처를 만들기 위하여 그전까지 객체지향개념과 컴퓨터 과학을 연결하며 학습하는 것이다. 